---
layout: post
title: Memory Corruption & Control Flow Hijacking
subtitle: 
cover-img: /assets/img/path.jpg
thumbnail-img: /assets/img/thumb.png
share-img: /assets/img/path.jp g
tags: [Binary-Exploit]
author: BitInfiltrator
---

First of all, we need to create a file, and i call it `program.c` and open this up, we write our little `int main`, we've got memory corruption what does that mean? well it means we got memory first and foremost before we can have memory corruption. How do we get some memory in C? lets create just a little buffer and we'll say this buffer can hold 100 bytes:
```
int main()
{
    char buffer[100];
}
```
now let's read into the buffer, if you were a normal person you would probably write this as like let's read from zero for standard in, read into the buffer, and maybe you want to be like real explicit and say `&buffer` but `buffer` is the same thing in this case and you might say `sizeof(buffer)`, because the sizeof this buffer is 100 we use sizeof to just not even mess around, we know what is gonna happen, if i compile the following code:
```
#include <unistd.h>

int main()
{
    char buffer[100];
    read(0,buffer, sizeof(buffer));
}
```
using gcc compiler and i say `gcc program.c`